//TODO:
CHANGE SEARCH CONTROLLER TO GET NEW INFO FROM PAGES OF THE SERVICE
CHANGE API CONTROLLER TO USE THE INFO FROM SEARCH CONTROLLER
UTILISE MAIN PAGE CONTROLLER TO USE EVERYTHING TO DO FUNCTIONS
@Service
public class SearchService {
    @Autowired
    private PageRepository pageRepo;
    @Autowired
    private SiteRepository siteRepo;
    @Autowired
    private LemmaRepository lemmaRepo;
    @Autowired
    private IndexRepository indexRepo;
    private final MorphologyService morphologyService = new MorphologyService();
    private final ConnectionService connectionService = new ConnectionService();
    private static final Logger log = LoggerFactory.getLogger(SearchService.class);

    public QueryResult searchAllSites(String query, String site, int offset, int limit) {
        QueryResult queryResult = new QueryResult();
        List<SingleResult> resultList = new ArrayList<>();
        //log.info("Searching for query: '{}' for site: '{}', offset: {}, limit: {}", query, site, offset, limit);
        try {
            if (site != null) {
                //log.info("Searching within site: '{}'", site);
                SiteEntity entity = siteRepo.getReferenceById(siteRepo.findIdByUrl(site));
                List<SingleResult> results = searchSite(query, entity, limit);
                resultList.addAll(results);
            } else {
                log.info("Searching across all sites");
                for (SiteEntity entity : siteRepo.findAll()) {
                    log.info("Searched through site: "+ entity.getUrl());
                    resultList.addAll(searchSite(query, entity, limit));
                    //log.info("Results found: ");
                    for (SingleResult singleResult : resultList) {
                        log.info(singleResult.toString());
                    }
                }
            }
            if (!resultList.isEmpty()) {
                //log.info("Sorting results by relevance");
                resultList.sort(Comparator.comparing(SingleResult::getRelevance).reversed());
                //log.info("Responses after sorting: " + resultList.size());
                queryResult.setData(resultList);
            }
            //log.info("Result ready: " + queryResult.toString());
            queryResult.setCount(queryResult.getData().size());
            queryResult.setResult(true);
        } catch (Exception e) {
            log.info("Search disrupted by exception: " + e.getLocalizedMessage());
            queryResult.setResult(false);
        }
        return queryResult;
    }
    private List<SingleResult> searchSite(String query, SiteEntity site, int limit) {
        log.info("query: " + query);
        log.info("site: " + site);
        List<SingleResult> responses = new ArrayList<>();
        Integer siteId = site.getId();
        List<String> queryWords = new ArrayList<>(morphologyService.decomposeTextToLemmasWithRank(query).keySet());
        log.info("Decomposed query into words/lemmas: {}", queryWords);
        List<LemmaEntity> queryLemmas = fetchRelevantLemmas(queryWords, siteId);
        for (LemmaEntity entity : queryLemmas) {
            log.info("found lemma entity: " + entity.toString());
        }
        if (queryLemmas.isEmpty()) {
            log.info("No relevant lemmas found for query: '{}' on site: {}", query, site.getUrl());
            return responses;
        }
        List<PageEntity> pageList = fetchRelevantPages(queryLemmas);
        for (PageEntity page : pageList) {
            log.info("check page: ");
            if (page.getContent() != null) {
                log.info("page content is not null");
            }
            if (page.getPath() != null) {
                log.info("page path: " + page.getPath());
            }
        }
        for (PageEntity entity : pageList) {
            //log.info("Processing page with path: {}", entity.getPath());
            String html = entity.getContent();
            log.info("page content length: " + html.length());
            List<String> snippets = generateSnippets(queryWords, html);
            //log.info("Generated {} snippets for page: {}", snippets.size(), entity.getPath());
            float relevance = calculateRelevance(entity, queryLemmas);
            log.info("Calculated relevance for page '{}': {}", entity.getPath(), relevance);
            for (String snippet : snippets) {
                //log.info("Adding snippet for page '{}': {}", entity.getPath(), snippet);
                String siteUrl = site.getUrl();
                String entityPath = entity.getPath();
                String title = connectionService.getTitle(entity.getContent());
                log.info("site url: " + site.getUrl() + "\n, entity path: " + entity.getPath() + "\n, title: " + title + "\n, snippet: " + snippet + "\n, relevance: " + relevance);
                responses.add(new SingleResult(siteUrl, entityPath, title, snippet, relevance));
            }
        }
        //log.info("Completed search for query: '{}' on site: {}, found {} results", query, site.getUrl(), responses.toString());
        return responses;
    }
    private List<LemmaEntity> fetchRelevantLemmas(List<String> queryWords, Integer siteId) {
        List<LemmaEntity> relevantLemmas = queryWords.stream()
                .map(word -> lemmaRepo.findByLemmaAndSiteId(word, siteId))
                .filter(Objects::nonNull)
                .filter(lemma -> lemma.getFrequency() < lemmaRepo.count() / 2)
                .sorted(Comparator.comparing(LemmaEntity::getFrequency).reversed())
                .collect(Collectors.toList());
        return relevantLemmas;
    }
    private List<PageEntity> fetchRelevantPages(List<LemmaEntity> queryLemmas) {
        List<PageEntity> pages = queryLemmas.stream()
                .flatMap(lemma -> indexRepo.findAllPagesByLemma(lemma).stream())
                .collect(Collectors.toList());
        return pages;
    }
    private float calculateRelevance(PageEntity entity, List<LemmaEntity> queryLemmas) {
        return queryLemmas.stream()
                .map(lemma -> indexRepo.findByPageAndLemma(entity, lemma))
                .filter(Objects::nonNull)
                .map(IndexEntity::getRankScore)
                .reduce(0f, Float::sum);
    }
    private List<String> generateSnippets(List<String> queryWords, String html) {
        Document document = Jsoup.parse(html);
        Set<String> snippets = new LinkedHashSet<>();
        document.body().select("*").forEach(element -> {
                if (new HashSet<>(morphologyService.lemmatizeElementContent(element)).containsAll(queryWords)) {
                    String text = element.ownText();
                    String highlightedSnippet = highlightQueryWordsAndTrim(text, queryWords);
                    if (!highlightedSnippet.isEmpty()) {
                        snippets.add(highlightedSnippet);
                    }
                }
        });
        return new ArrayList<>(snippets);
    }
    private String highlightQueryWordsAndTrim(String text, List<String> queryWords) {
        int wordsBefore = 2;
        int wordsAfter = 20;
        Set<String> lemmatizedQueryWords = queryWords.stream()
                .map(morphologyService::lemmatizeWord)
                .collect(Collectors.toSet());
        String[] words = text.split("\\s+");
        StringBuilder snippetBuilder = new StringBuilder();
        boolean isQueryMatched = false;
        for (int i = 0; i < words.length; i++) {
            String lemmatizedWord = morphologyService.lemmatizeWord(words[i].replaceAll("[^\\w]", "").toLowerCase());
            if (lemmatizedQueryWords.contains(lemmatizedWord)) {
                isQueryMatched = true;
                int start = Math.max(0, i - wordsBefore);
                int end = Math.min(words.length, i + wordsAfter + 1);
                for (int j = start; j < end; j++) {
                    if (j == i) {
                        snippetBuilder.append("<b>").append(words[j]).append("</b> ");
                    } else {
                        snippetBuilder.append(words[j]).append(" ");
                    }
                }
                snippetBuilder.append("... ");
            }
        }
        return isQueryMatched ? snippetBuilder.toString().trim() : "";
    }
}